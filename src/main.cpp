/* 
 * File:   main.cpp
 * Author: Mosab Bazargani
 * 
 * 
 * ############# Description ###################################################
 * Entry point for the entire project. This is the implementation 
 * of the following algorithms for symmetric TSP instances:
 *      - LAHC
 *      - pLAHC 
 *      - pLAHC-s 
 *
 * All results are presented in the "Parameter-less Late Acceptance 
 * Hill-Climbing" paper, published in GECCO'17, are generated by using 
 * this application.
 * 
 * ############# Building ######################################################
 * To compile you will need C++11. We use gcc version 4.8.1 for our compilation.
 * Our build system uses Makefiles. You can compile the application by typing 
 * "make" at the command line. It will generate the executable file "pLAHC".
 * 
 * ############# Running an Experiment #########################################
 * To run an experiment, the executable file "pLAHC", TSP instance and input 
 * file must be in the same directory. For example by typing the following at 
 * the command line:
 * ./pLAHC inputfile
 * Three sample input files that were used in the experiments described in the
 * GECCO'17 paper for the TSP instance "rat783.tsp" are given in the 
 * directory "sample_inputfiles". 
 * 
 * ############# Output Files ##################################################
 * All of the output files will be generated in the same directory as the 
 * executable file "pLAHC". The output file that contains the main output data 
 * has a name ending with ".log". The application also produces some other 
 * files for data analysis purposes.
 * 
 * ############# License #######################################################
 * BSD 3-Clause License
 * 
 * Copyright (c) 2017, Mosab Bazargani
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <iostream>
#include <iomanip>
#include <fstream>
#include "Configuration.h"
#include "TSPLIB.h"
#include "LAHC.h"
#include "Util.h"
#include "Random.h"
#include "Statistic.h"
#include "pLAHC.h"
#include "pLAHC_s.h"

using namespace std;
Random RANDOM;

int main(int argc, char** argv) {
    // process command line
    if (argc < 2) {
        cout << "Usage: " << argv[0] << " inputfile" << endl;
        exit(1);
    }

    // read parameters from inputfile

    Configuration config(argv[1]);

    // set the log file
    ofstream logfile((config.output + ".log").c_str(), ios_base::out);

    // set the progress file
    if (config.restore_progress == "on") {
        ofstream progress((config.output + ".progress").c_str(),
                ios_base::out);
        if (config.algorithm == "LAHC" || config.algorithm == "seedexplahc")
            progress << "# (iteration, best_tour_length, list_avg)" << endl;
        else if (config.algorithm == "pLAHC")
            progress << "# (iteration, effective_iteration, best_so_far, "
                "best_so_far_lsize, current_lsize, current_list_best, "
                "current_list_iteration, current_list_effective_iteration, "
                "current_list_avg)" << endl;
        progress.close();
    }

    // set the special events file
    if (config.restore_special_events == "on" &&
            (config.algorithm == "pLAHC" ||
            config.algorithm == "seedexplahc")) {
        ofstream events((config.output + ".events").c_str(),
                ios_base::out);
        events << "# (lsize, starting_iteration, ending_iteration,"
                " num_iterations, num_effective_iteration, best_tour, list_avg)"
                << endl;
        events.close();
    }

    // set the best results file
    if (config.restore_best_results == "on") {
        ofstream bests((config.output + ".bests").c_str(),
                ios_base::out);
        if (config.algorithm == "lahc" || config.algorithm == "seedexplahc")
            bests << "# run iterations best_length avg.list" << endl;
        else if (config.algorithm == "pLAHC")
            bests << "# run iterations best_length best_lsize "
                "best_lsize_iterations avg.last_best_list" << endl;
        bests.close();
    }

    // dump parameters in the log file
    logging(logfile, config.dump_parameters());

    // Set up the random number seed using the configuration value
    RANDOM.randomize(double(1. / config.seed));

    // read the given TSP instance file.
    logging(logfile, "Start reading the given `TSP` instance -- " +
            config.problem_name);
    TSPLIB tsp_instance(config.problem_name);

    // run the application
    unsigned long sum_iterations = 0;
    if (config.algorithm == "LAHC") {
        // to collect results
        vector<lahc_results> sum_results; // to calculate the avg of several runs
        vector<lahc_results> **collective_results; // to collect run's results
        collective_results = new vector<lahc_results>*[config.num_run];
        for (int i = 0; i < config.num_run; i++)
            collective_results[i] = new vector<lahc_results>;

        logging(logfile, "Start LAHC ...");
        cout << "Start LAHC ..." << endl;
        for (int i = 0; i < config.num_run; i++) {
            logging(logfile, "Starting Run " + integer2string(i + 1, 3));
            LAHC lahc(tsp_instance, config.stopping, config.list_size);
            lahc.run();
            logging(logfile, lahc.report_best_result());
            if (config.restore_progress == "on")
                lahc.report_progress(config.output + ".progress",
                    integer2string(i + 1, 3));
            if (config.restore_best_results == "on")
                lahc.report_best_results(config.output + ".bests",
                    integer2string(i + 1, 3));

            lahc.copy_results(collective_results, i);
            sum_iterations += lahc.num_iterations();
        }
        // report the average of runs into the log file
        lahc_runs_avg(collective_results, sum_results, 1000, config.num_run);
        string msg = "";
        msg += "======================================\n";
        msg += std::string(21, ' ') + ">>> avg. iterations:       ";
        msg += std::to_string(sum_iterations / double(config.num_run)) + "\n";
        msg += std::string(21, ' ') + ">>> avg. best_tour_length: ";
        msg += std::to_string(sum_results.back().best_tour_length /
                double(config.num_run)) + "\n";
        msg += std::string(21, ' ') + ">>> list avg.:             ";
        msg += std::to_string(sum_results.back().list_avg /
                double(config.num_run));
        logging(logfile, msg);
        store_lahc_average(config.output + ".avg", sum_results, config.num_run);
        cout << "LAHC for input file `" << config.inputfile << "` for `" <<
                config.num_run << "` runs is DONE!" << endl;

        // free memory
        sum_results.resize(0);
        sum_results.clear();
        sum_results.shrink_to_fit();
        for (int i = 0; i < config.num_run; i++) {
            collective_results[i]->clear();
            delete collective_results[i];
        }
        delete [] collective_results; //
    } else if (config.algorithm == "pLAHC") {
        // to collect results
        vector<explahc_results> **collective_results; // to collect run's results
        collective_results = new vector<explahc_results>*[config.num_run];
        for (int i = 0; i < config.num_run; i++)
            collective_results[i] = new vector<explahc_results>;

        // to collect special events of all runs
        vector<explahc_special_events> **collective_special_events;
        collective_special_events =
                new vector<explahc_special_events>*[config.num_run];
        for (int i = 0; i < config.num_run; i++)
            collective_special_events[i] =
                new vector<explahc_special_events>;
        logging(logfile, "Start pLAHC ...");
        cout << "Start pLAHC for inputfile `" << config.inputfile <<
                "` ..." << endl;
        for (int i = 0; i < config.num_run; i++) {
            logging(logfile, "Starting Run " + integer2string(i + 1, 3));
            pLAHC explahc(tsp_instance, config.stopping,
                    config.base_list_size, config.list_scaling_size);
            explahc.run();
            logging(logfile, explahc.report_best_result());
            if (config.restore_progress == "on")
                explahc.report_progress(config.output + ".progress",
                    integer2string(i + 1, 3));
            if (config.restore_special_events == "on")
                explahc.report_special_events(config.output + ".events",
                    integer2string(i + 1, 3));
            if (config.restore_best_results == "on")
                explahc.report_best_results(config.output + ".bests",
                    integer2string(i + 1, 3));
            // collect results of a single run
            explahc.copy_special_events(collective_special_events, i);
            explahc.copy_results(collective_results, i);
        }

        logging(logfile, report_explahc_result_summary(
                collective_special_events, config.num_run));
        store_explahc_runs_average(config.output + ".avg",
                collective_results, 1000, config.num_run);
        cout << "pLAHC for input file `" << config.inputfile
                << "` for `" << config.num_run << "` runs is DONE!" << endl;

        for (int i = 0; i < config.num_run; i++) {
            collective_special_events[i]->clear();
            delete collective_special_events[i];
        }
        delete [] collective_special_events;
    } else if (config.algorithm == "pLAHC-s") {
        // to collect results
        vector<explahc_results> **collective_results; // to collect run's results
        collective_results = new vector<explahc_results>*[config.num_run];
        for (int i = 0; i < config.num_run; i++)
            collective_results[i] = new vector<explahc_results>;

        // to collect special events of all runs
        vector<explahc_special_events> **collective_special_events;
        collective_special_events =
                new vector<explahc_special_events>*[config.num_run];
        for (int i = 0; i < config.num_run; i++)
            collective_special_events[i] =
                new vector<explahc_special_events>;
        logging(logfile, "Start pLAHC-s ...");
        cout << "Start pLAHC-s for inputfile `" <<
                config.inputfile << "` ..." << endl;
        for (int i = 0; i < config.num_run; i++) {
            logging(logfile, "Starting Run " + integer2string(i + 1, 3));
            pLAHC_s seedexplahc(tsp_instance, config.stopping,
                    config.base_list_size, config.list_scaling_size);
            seedexplahc.run();
            logging(logfile, seedexplahc.report_best_result());
            if (config.restore_progress == "on")
                seedexplahc.report_progress(config.output + ".progress",
                    integer2string(i + 1, 3));
            if (config.restore_special_events == "on")
                seedexplahc.report_special_events(config.output + ".events",
                    integer2string(i + 1, 3));
            if (config.restore_best_results == "on")
                seedexplahc.report_best_results(config.output + ".bests",
                    integer2string(i + 1, 3));
            // collect results of a single run
            seedexplahc.copy_special_events(collective_special_events, i);
            seedexplahc.copy_results(collective_results, i);
        }

        logging(logfile, report_explahc_result_summary(
                collective_special_events, config.num_run));
        store_explahc_runs_average(config.output + ".avg",
                collective_results, 1000, config.num_run);
        cout << "pLAHC-s for input file `" <<
                config.inputfile << "` for `" << config.num_run <<
                "` runs is DONE!" << endl;

        for (int i = 0; i < config.num_run; i++) {
            collective_special_events[i]->clear();
            delete collective_special_events[i];
        }
        delete [] collective_special_events;
    }
    // close the log file
    logfile.close();
    return 0;
}
